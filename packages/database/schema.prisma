generator client {
  provider        = "prisma-client-js"
  previewFeatures = ["postgresqlExtensions"]
}

datasource db {
  provider   = "postgresql"
  url        = env("DATABASE_URL")
  extensions = [postgis]
}

enum Role {
  SUPER_ADMIN
  CAMPUS_ADMIN
  CASHIER
  LECTURER
  STUDENT
  GUEST
}

enum RoomType {
  LECTURE_HALL
  LAB
  OFFICE
  OTHER
}

enum PaymentStatus {
  PENDING
  CLEARED
  FAILED
}

enum RecurrencePattern {
  NONE
  WEEKLY
  BIWEEKLY
}

enum StaffPosition {
  VICE_CHANCELLOR
  DEAN
  HOD // Head of Department
  REGISTRAR
  BURSAR
  LIBRARIAN
  IT_ADMIN
  LECTURER
  ASSISTANT_LECTURER
  SECURITY
  JANITOR
  DRIVER
}

model Campus {
  id        String @id @default(uuid())
  slug      String @unique
  townName  String @map("town_name")
  centerLat Float  @map("center_lat")
  centerLng Float  @map("center_lng")

  // Unsupported type for PostGIS Polygon. Handled via raw SQL in migration/seeding usually, 
  // but Prisma now supports some extensions. For now, we keep it as a supported type or string 
  // if specific PostGIS types aren't fully typed in Prisma Schema yet without extensions.
  // We will use standard `Unsupported("geometry(Polygon, 4326)")` for real PostGIS usage.
  boundaryGeoJson Unsupported("geometry(Polygon, 4326)")? @map("boundary")

  buildings    Building[]
  users        User[]
  forcedEvents TimetableEvent[]

  @@map("campuses")
}

model Building {
  id        String @id @default(uuid())
  campusId  String @map("campus_id")
  name      String
  shortCode String @map("short_code")

  location Unsupported("geometry(Geometry, 4326)")? @map("geom")

  campus Campus  @relation(fields: [campusId], references: [id])
  floors Floor[]

  @@map("buildings")
}

model Floor {
  id           String  @id @default(uuid())
  buildingId   String  @map("building_id")
  floorNumber  Int     @map("floor_number")
  planImageUrl String? @map("plan_image_url")

  // Could be GeoJSON or just a simple image storage

  building Building @relation(fields: [buildingId], references: [id])
  rooms    Room[]

  @@map("floors")
}

model Room {
  id       String   @id @default(uuid())
  floorId  String   @map("floor_id")
  roomCode String   @map("room_code") // e.g., "A-101"
  capacity Int
  type     RoomType

  location Unsupported("geometry(Point, 4326)")? @map("geom")

  floor  Floor            @relation(fields: [floorId], references: [id])
  events TimetableEvent[]

  @@map("rooms")
}

model User {
  id                   String    @id @default(uuid())
  role                 Role
  campusIdHome         String?   @map("campus_id_home")
  institutionalEmail   String    @unique @map("institutional_email") // Immutable
  recoveryEmail        String?   @map("recovery_email") // Mutable
  phone                String?
  fullName             String    @map("full_name")
  createdFromPaymentId String?   @unique @map("created_from_payment_id")
  isActive             Boolean   @default(false)
  password             String    // Hashed with bcrypt
  passwordChangedAt    DateTime? @map("password_changed_at")

  campus                Campus?                  @relation(fields: [campusIdHome], references: [id])
  payment               Payment?                 @relation(fields: [createdFromPaymentId], references: [id])
  enrollments           Enrollment[]
  lecturerEvents        TimetableEvent[]         @relation("LecturerEvents")
  staffMember           StaffMember?
  complaints            Complaint[]
  profileChangeRequests ProfileChangeRequest[]   @relation("UserRequests")
  reviewedRequests      ProfileChangeRequest[]   @relation("ReviewedRequests")
  auditLogs             AuditLog[]

  @@map("users")
}

model Payment {
  id               String        @id @default(uuid())
  externalRef      String        @unique @map("external_ref")
  studentMatricule String?       @map("student_matricule")
  studentName      String?       @map("student_name")
  personalEmail    String?       @map("personal_email")
  phoneNumber      String?       @map("phone_number")
  amount           Decimal
  clearedAt        DateTime?     @map("cleared_at")
  status           PaymentStatus

  // Notification tracking
  credentialsSentAt DateTime? @map("credentials_sent_at")
  emailSent         Boolean   @default(false) @map("email_sent")
  smsSent           Boolean   @default(false) @map("sms_sent")
  whatsappSent      Boolean   @default(false) @map("whatsapp_sent")

  user User?

  @@map("payments")
}

model Department {
  slug        String       @id
  name        String
  courses     Course[]
  enrollments Enrollment[]

  @@map("departments")
}

model Enrollment {
  id             String @id @default(uuid())
  userId         String @map("user_id")
  departmentSlug String @map("department_slug")
  programSlug    String @map("program_slug")
  level          Int // e.g. 100, 200, 300
  academicYear   String @map("academic_year")

  user       User       @relation(fields: [userId], references: [id])
  department Department @relation(fields: [departmentSlug], references: [slug])

  @@map("enrollments")
}

model Course {
  id             String @id @default(uuid())
  code           String @unique // "CSC301"
  title          String
  credits        Int
  departmentSlug String @map("department_slug")

  department Department       @relation(fields: [departmentSlug], references: [slug])
  events     TimetableEvent[]

  @@map("courses")
}

model TimetableEvent {
  id                String            @id @default(uuid())
  courseId          String            @map("course_id")
  roomId            String            @map("room_id")
  weekday           Int // 0=Sun, 1=Mon...
  startTime         DateTime          @map("start_time") // Time only, usually specific date in real instances or just Time if recurring? Assuming generic schedule: Time of day.
  endTime           DateTime          @map("end_time")
  recurrencePattern RecurrencePattern
  campusIdForced    String?           @map("campus_id_forced") // If event happens at a specific campus override

  course Course  @relation(fields: [courseId], references: [id])
  room   Room    @relation(fields: [roomId], references: [id])
  campus Campus? @relation(fields: [campusIdForced], references: [id])

  lecturers User[] @relation("LecturerEvents")

  @@map("timetable_events")
}

model StaffMember {
  id           String        @id @default(uuid())
  userId       String        @unique @map("user_id")
  position     StaffPosition
  departmentId String?       @map("department_id")
  salary       Decimal?
  hireDate     DateTime      @map("hire_date")

  user       User        @relation(fields: [userId], references: [id])
  complaints Complaint[]

  @@map("staff_members")
}

model ProfileChangeRequest {
  id              String    @id @default(uuid())
  userId          String    @map("user_id")
  requestType     String    @map("request_type") // "NAME_CHANGE", "EMAIL_CHANGE"
  oldValue        String    @map("old_value")
  newValue        String    @map("new_value")
  reason          String
  status          String    @default("PENDING") // "PENDING", "APPROVED", "REJECTED"
  reviewedById    String?   @map("reviewed_by_id")
  rejectionReason String?   @map("rejection_reason")
  createdAt       DateTime  @default(now()) @map("created_at")
  reviewedAt      DateTime? @map("reviewed_at")

  user       User  @relation("UserRequests", fields: [userId], references: [id])
  reviewedBy User? @relation("ReviewedRequests", fields: [reviewedById], references: [id])

  @@map("profile_change_requests")
}

model Complaint {
  id            String        @id @default(uuid())
  userId        String        @map("user_id")
  category      String        // "PAYMENT", "TIMETABLE", "FACILITY", "ACADEMIC", "HARASSMENT", "OTHER"
  subject       String
  description   String        @db.Text
  status        String        @default("OPEN") // "OPEN", "IN_PROGRESS", "RESOLVED", "CLOSED"
  priority      String        @default("MEDIUM") // "LOW", "MEDIUM", "HIGH", "URGENT"
  assignedToId  String?       @map("assigned_to_id")
  response      String?       @db.Text
  statusHistory Json[]        @default([]) @map("status_history")
  createdAt     DateTime      @default(now()) @map("created_at")
  updatedAt     DateTime      @updatedAt @map("updated_at")

  user       User          @relation(fields: [userId], references: [id])
  assignedTo StaffMember?  @relation(fields: [assignedToId], references: [id])

  @@map("complaints")
}

model AuditLog {
  id          String   @id @default(uuid())
  userId      String   @map("user_id")
  action      String   // "LOGIN", "LOGOUT", "PROFILE_UPDATE", "COMPLAINT_CREATED", etc.
  description String
  metadata    Json?    // Additional context data
  createdAt   DateTime @default(now()) @map("created_at")

  user User @relation(fields: [userId], references: [id])

  @@map("audit_logs")
}
